# Kubernetes In One-Shots Explanations:-
# ğŸ”¹ Core Concepts Of Kubernetes:-

## ğŸ§± 1. Monolithic vs Microservices
### ğŸ§© Monolithic Architecture
* The entire application is built as one single unit.
* All components (UI, business logic, database access) are tightly coupled.
* ğŸ‘‰ Example:-
* A shopping app where product listing, cart, and payment are all in one big codebase.
### Pros:
* Simple to develop, test, and deploy initially.
* Easier for small applications.
### Cons:
* Hard to scale (you must scale the entire app even if one part needs more resources).
* Difficult to update â€” one small change can require redeploying the entire app.
* Slower development when the app grows.

### âš™ï¸ Microservices Architecture
* Application is divided into small independent services, each focusing on a specific function (e.g., User Service, Payment Service, Order Service).
* Each service runs in its own container or pod, often managed by Kubernetes.
### Pros:
* Independent deployment and scaling.
* Easier fault isolation â€” one service failing doesnâ€™t crash the whole app.
* Better suited for cloud-native and DevOps environments.
### Cons:
* More complex networking and monitoring.
* Requires orchestration (like Kubernetes) to manage services.

## â˜¸ï¸ 2. Kubernetes Architecture
ğŸ§  Control Plane (Master Node)
* Responsible for managing and controlling the cluster.
### Components:
* API Server â€“ The main entry point; all commands go through it (kubectl communicates here).
* etcd â€“ Key-value store that holds cluster state and configuration.
* Controller Manager â€“ Ensures the desired state matches the actual state.
* Scheduler â€“ Assigns pods to available nodes.
* Cloud Controller Manager â€“ Integrates with cloud providers (AWS, Azure, etc.).

## ğŸ–¥ï¸ Worker Node (Minion Node)
*Runs your actual workloads (pods).
### Components:
* Kubelet â€“ Communicates with the master; ensures pods are running.
* Kube-proxy â€“ Handles network routing and service discovery.
* Container Runtime â€“ Runs containers (Docker, containerd, etc.).

## ğŸ’» 3. Kubernetes Setup
### ğŸ§© A. Local Setup (using Minikube or Kind)
ğŸ”¹ Minikube
####  Install Minikube and kubectl
* minikube start --driver=docker

#### Check cluster status
* kubectl get nodes

ğŸ”¹ Kind (Kubernetes in Docker)
* kind create cluster
* kubectl cluster-info

## â˜ï¸ B. AWS EC2 Setup
### 1. Create EC2 Instances:
* 1 Master Node
* 1+ Worker Nodes
* Use Ubuntu 20.04 or Amazon Linux 2.

### 2. Install Docker, Kubeadm, Kubectl, and Kubelet:
* sudo apt update
* sudo apt install -y docker.io apt-transport-https curl
* curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
* echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
* sudo apt update
* sudo apt install -y kubelet kubeadm kubectl
* sudo systemctl enable kubelet && sudo systemctl start kubelet

### 3. Initialize the Cluster (on Master Node):
* sudo kubeadm init --pod-network-cidr=10.244.0.0/16

### 4. Set up kubectl access:
* mkdir -p $HOME/.kube
* sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
* sudo chown $(id -u):$(id -g) $HOME/.kube/config

### 5. Install Network Add-on (e.g., Flannel):
* kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml

### 6. Join Worker Nodes:
* Use the token generated by kubeadm init:
* sudo kubeadm join <master-ip>:6443 --token <token> --discovery-token-ca-cert-hash sha256:<hash>

## ğŸ§  4. kubectl (Kubernetes Command-Line Tool)
* kubectl get nodes	-----List cluster nodes
* kubectl get pods	-----List pods
* kubectl create -f file.yaml	-----Create resource from YAML file
* kubectl apply -f file.yaml	-----Apply/update configuration
* kubectl describe pod <pod-name>	-----Show pod details
* kubectl logs <pod-name>	-----View pod logs
* kubectl delete pod <pod-name>	-----Delete a pod

## ğŸ§± What is Pods...?
### Ans: 
* The smallest deployable unit in Kubernetes.
* A Pod contains one or more containers that share:
    * The same network IP
    * Storage
    * Configuration
* Think of a pod as a â€œwrapperâ€ around your container(s).

## ğŸ—‚ï¸ What is Namespaces...?
### Ans:
* Used to logically separate resources in a cluster.
* Example: dev, test, and prod namespaces to isolate environments.
### Commands Is:-
* kubectl create namespace dev
* kubectl get namespaces
* kubectl get pods -n dev

## What is Labels And Selectors....?
### Ans: 
* Labels: Key-value pairs assigned to objects (used for grouping/filtering).
* Selectors: Query/filter resources using labels.
### ğŸ”¹ Example Of Labrls:-
* metadata:
  * labels:
    * app: frontend

### ğŸ”¹ Example Of Selector:-
* selector:
  * matchLabels:
    * app: frontend

## ğŸ“ What is Annotations...?
### Ans:
* Store non-identifying metadata for resources (like build info, version, or notes).
* Not used for selection.
### ğŸ”¹ Example of Annotations
* metadata:
  * annotations:
    * buildVersion: "v1.0"
    * maintainer: "team@company.com"

# ğŸ”¹ Workloads Of Kubernetes:
## â˜¸ï¸ Kubernetes Workloads Overview:
### In Kubernetes, a Workload is an object that defines how your application runs â€” how many Pods, how they update, how they store data, and how they recover if something fails

## All workloads manage Pods.

## ğŸš€ 1. Deployment Workloads:-
### Ans:-
### ğŸ“˜ Purpose:
* The most common workload.
* Manages stateless applications (apps that donâ€™t need to remember data between restarts).
* Uses ReplicaSets behind the scenes to ensure desired Pod count.

### ğŸ§  Features:
* Rolling updates and rollbacks.
* Scaling (up/down replicas easily).
* Self-healing (recreates failed Pods).
* ğŸ”¹ Use Case: Web servers, APIs, frontend apps â€” anything stateless.

## ğŸ§± 2. StatefulSet Workloads:-
### ğŸ“˜ Purpose:
* Used for stateful applications that require:
* Stable network identity (same Pod name).
* Persistent storage.
* Ordered deployment & scaling.

### ğŸ§  Features:
* Pods are created with unique, consistent names (e.g., db-0, db-1, db-2).
* Each Pod keeps its own persistent volume.
* ğŸ”¹ Use Case: Databases (MySQL, MongoDB), message queues (Kafka, RabbitMQ).

## âš™ï¸ 3. DaemonSet Workloads:-
### ğŸ“˜ Purpose:
* Ensures a copy of a Pod runs on every (or selected) Node.
* Commonly used for background system tasks.

### ğŸ§  Features:
* Automatically runs one Pod per Node.
* When a new Node is added, a Pod is automatically scheduled.
* ğŸ”¹ Use Case:
  * Node monitoring agents (Prometheus Node Exporter)
  * Logging (Fluentd, Filebeat)
  * Security agents.

## ğŸ§® 4. ReplicaSet Workloads
### ğŸ“˜ Purpose:
* Ensures a specified number of identical Pods are running at any time.
* Deployments use ReplicaSets internally â€” you rarely create them directly now.

### ğŸ§  Features:
* Self-healing: replaces crashed Pods.
* Doesnâ€™t handle updates or rollbacks (thatâ€™s Deploymentâ€™s job).
* ğŸ”¹ Use Case: Ensuring a fixed number of identical stateless Pods â€” but most teams use Deployments instead.

## ğŸ§° 5. Job Workloads:-
### ğŸ“˜ Purpose:
* Runs a task to completion (not long-running).
* Once the Pod finishes successfully, it doesnâ€™t restart.

### ğŸ§  Features:
* Good for one-time batch jobs or short-lived scripts.
* ğŸ”¹ Use Case: Data backup, file processing, batch tasks, migration scripts.

### â° 6. CronJob Workloads
## ğŸ“˜ Purpose:
* Runs Jobs on a schedule, like a Linux cron job.
* Example: â€œRun a backup every day at midnight.â€

### ğŸ§  Features:
* Uses cron syntax (*/5 * * * *) for scheduling.
* Each run creates a Job, which in turn creates Pods.
* ğŸ”¹ Use Case: Regular backups, data cleanup, scheduled notifications, etc.
